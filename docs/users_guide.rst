User's Manual
=============

Fortran Subroutine Annotation Syntax
------------------------------------

Motivation
''''''''''

In order for code to successfully be generated by the code generation tools,
each tool needs to be aware of specific information contained in all of the
subroutines that will be called. However, parsing Fortran routines for this
specific information can be difficult, and the code generation tools should have
as little knowledge of setup tool specifics as possible in order to simplify code
generation and reduce coupling. Therefore, we have developed a syntax for annotating
fortran subroutines, as well as a tool for processing that syntax, to be able to
generate Operation Specification JSONs. These JSONs, along with the simulation
recipe, have all of the information necessary to generate Task Function and Data
Item code. This syntax also reduces the burden on the user, since they don't need
to manually create the operation specification JSONs. As the syntax and parsing
tool become more advanced, the user will need to annotate less information.

Modern Fortran is case-insensitive, but a large portion of syntax keywords
are case-sensitive. While this annotation syntax is only used for static Fortran
subroutines, the underlying code generation tools generate both C++ and Fortran
code, and cannot assume what language they are generating code for. Some keywords
are also used directly when generating code. Therefore, keywords used by the code
generation tools must be case-sensitive. However, in keeping the spirit of Fortran
the names of any annotated variables will be case-insensitive. So, keywords inside
of a variable annotation are case-sensitive, but any variable name or attribute
value referencing a variable by name are not.

Variable Annotation
'''''''''''''''''''

In order to develop an operation specification, the user needs to annotate every
dummy argument inside each dummy argument list in all subroutines that are called
by a recipe. Annotating a variable uses the following format:

.. code-block::

    !! variable_name :: attribute_name1=value1, &
    !!                  attribute_name2=[low : high], &
    !!                  attribute_name3=value3 ...

Where the values of each attribute are strings, integer, or array values. Arrays
are surrounded by square brackets. Notice that if the user is declaring attributes
across multiple lines, they will need to use '&' as the line continuation character.

Generally, any valid keyword used by the Milhoja pypackage for Task Function arguments
is a valid keyword inside of this annotation syntax. The source for the Milhoja
pypackage documentation can be found here_.

.. _here: https://github.com/Flash-X/Milhoja/blob/master/tools/milhoja_pypkg/docs/source/users_manual.rst#argument_specifications

Attributes
""""""""""

The most important part of variable annotations are the list of attributes that
need to be associated with a variable.

Souce Attribute
^^^^^^^^^^^^^^^

This is the most important attribute to determine when annotating variables, and
is expected on every variable that needs to be annotated. There are a few different
accepted values for the source attribute. These are case-sensitive. All sources
have a list of required attributes that need to be included inside the variable
annotation if that source is being used. The list of valid sources includes:

â€¢ ``external``
    * Variables that update their values in each time step that appear in the
      driver code. As such, each variable must be passed into data item via a
      the Data Item constructor.
    * Ex: constants or delta time.
    * Required attributes: `origin`
        * `origin`: Tells the recipe tool where the input argument is obtained
                    from inside of the generated code, so that it can pass the
                    argument into the generated Data Item constructor.

* "tile" sources
    * Number of different "tile" type sources, these pull data from the tile descriptor.
    * All "tile" sources are available to view in the Milhoja documentation_.
    * Required attributes: None

.. _documentation: https://github.com/Flash-X/Milhoja/blob/master/tools/milhoja_pypkg/docs/source/users_manual.rst#tile_metadata-sources

* ``lbound``
    * Variables that are lower bounds of array variables
    * Required attributes: `array`
        * `array`: The array that this lower bound is associated with. This value
                   should be the name of an existing annotated variable that has 
                   an ``lbound`` attribute.

* ``grid_data``
    * Source for grid arrays, generally solution data or face arrays.
    * Required attributes: `structure_index`
        * `structure_index`: An array where the first element is some grid data
                             array {"CENTER", "FACEX", "FACEY", "FACEZ"}, and the
                             second element is the index (always 1 for now).
                             Ex: ["CENTER", 1]
    * Optional attributes: `r`, `rw`, `w`
        * All optional attributes are an array containing a range of indices.
          Must be contiguous.
        * `r`: The indices to read.
        * `w`: The indices to write
        * `rw`: The indices to read and write.

* ``scratch``
    * Variable is array data that is allocated on the device and used as scratch memory.
    * Required attributes: `extents`, `lbound`
        * `extents`: An array containing the size of each dimension in the array.
                     Ex: [NXB, NYB, NZB, NFLUXES] or [16, 16, 16, 5]. Only integers
                     are accepted. Can use the preprocessor to fill in values.
        * `lbound`: The lower bound of the array. Ex: [tile_lo, 1]. `tile_lo`
                    is a special keyword that inserts the lo array contained inside
                    of a tile, and is a 3 dimensional array. The dimensionality
                    of lbound must match the dimensionality of `extents`, and as
                    such, the array that this annotation is for.

Common attribute
^^^^^^^^^^^^^^^^

The second most important attribute. If a variable that is defined inside of a
subroutine section is a variable that is passed into multiple other subroutines,
then that variable needs to be defined inside of a common section. For any variable
inside of a subroutine that is defined inside of a common section, the only attribute
inside of the annotation should be a `common`, where the value is the name of the
associated variable inside the common section. Do not use this attribute inside of
common sections.

Ex:

..code-block::

    !! dt :: common=_common_dt

Section Types
'''''''''''''

There are two types of sections that the annotation syntax uses, common and subroutine
sections.

Common Section
""""""""""""""

Common sections contain annotations of variables that are passed into multiple
different subroutines. Common sections always go above all subroutine sections,
because subroutine sections rely on information found inside of the common section.
Common sections are surrounded by `!!milhoja begin common` and `!!milhoja end common`
statements. All variable annotations go inbetween.

Ex:

.. code-block::

    !!milhoja begin common
    !!   _Uin :: source=grid_data, &
    !!           structure_index=[center, 1], &
    !!           RW=[1:NUNK_VARS]
    !!   _blkLimits :: source=tile_interior
    !!   _blkLimitsGC :: source=tile_arrayBounds
    !!   _lo :: source=tile_lo
    !!   _loGC :: source=tile_lbound
    !!   _hy_starState :: source=scratch, &
    !!                    type=real, &
    !!                    extents=[MILHOJA_BLOCK_GC, NUNK_VARS], &
    !!                    lbound=[tile_lbound, 1]
    !!   _hy_tmpState :: source=scratch, &
    !!                   type=real, &
    !!                   extents=[MILHOJA_BLOCK_GC, NUNK_VARS], &
    !!                   lbound=[tile_lbound, 1]
    !!   _stage :: source=external, &
    !!             type=integer, &
    !!             origin=local:stage
    !!   _dt :: source=external, &
    !!          type=real, &
    !!          origin=input_arg:dt
    ...
    !!milhoja end common

Subroutine Sections
"""""""""""""""""""

Subroutine sections contain annotations of each variable inside of the dummy
argument list. In order to annotate a subroutine, surround the subroutine with
`!!milhoja begin` and `!!milhoja end` statements. Then, place every variable
annotation between the `!!milhoja begin` statement, and the line that contains
the subroutine keyword for the subroutine.

Ex:

.. code-block::

    interface
        !!milhoja begin
        !!  Uin :: common=_Uin
        !!  hy_Vc :: source=scratch, &
        !!           type=real, &
        !!           extents=[MILHOJA_BLOCK_GC], &
        !!           lbound=[tile_lbound]
        !!  blkLimits :: common=_blkLimits
        !!  blkLimitsGC :: common=_blkLimitsGC
        !!  hy_starState :: common=_hy_starState
        !!  hy_tmpState :: common=_hy_tmpState
        !!  stage :: common=_stage
        !!  lo :: common=_lo
        !!  loGC :: common=_loGC
        subroutine Hydro_prepBlock(Uin, hy_Vc, blkLimits, blkLimitsGC, hy_starState, hy_tmpState, &
                                stage, lo, loGC)
            implicit none
            integer, intent(IN) :: lo(3), loGC(3)
            real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(IN OUT) :: Uin
            real, dimension(1:, loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_starState, hy_tmpState
            real, dimension(loGC(1):, loGC(2):, loGC(3):), intent(OUT) :: hy_Vc
            integer, dimension(LOW:HIGH, MDIM), intent(IN) :: blkLimits, blkLimitsGC
            integer, intent(IN) :: stage
            end subroutine Hydro_prepBlock
        !!milhoja end
    end interface
